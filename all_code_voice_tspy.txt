

### FILE: collate_voice.py

import os

OUTPUT_FILE = "all_code_voice_tspy.txt"
EXTS = {".py", ".ts", ".tsx"}
EXCLUDE_DIRS = {"node_modules", "dist", "build", ".git"}

with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    for dirpath, dirnames, filenames in os.walk("."):
        # Remove excluded dirs in-place (prevents os.walk from descending)
        dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
        for fname in filenames:
            if os.path.splitext(fname)[-1].lower() in EXTS:
                rel_path = os.path.relpath(os.path.join(dirpath, fname), ".")
                out.write(f"\n\n### FILE: {rel_path}\n\n")
                try:
                    with open(os.path.join(dirpath, fname), "r", encoding="utf-8") as f:
                        out.write(f.read())
                except Exception as e:
                    out.write(f"\n[ERROR reading {rel_path}: {e}]\n")

print(f"Collated all .py, .ts, .tsx files into {OUTPUT_FILE} (excluding node_modules, dist, build, .git)")


### FILE: testtest.py

import os

def print_files(root_folder, extensions):
    found = False
    for dirpath, _, filenames in os.walk(root_folder):
        for fname in filenames:
            ext = os.path.splitext(fname)[-1].lower()
            if ext in extensions:
                rel_path = os.path.relpath(os.path.join(dirpath, fname), root_folder)
                print(rel_path)
                found = True
    if not found:
        print(f"No matching files found in {root_folder} for extensions: {extensions}")

# Check soul
if os.path.exists("soul"):
    print("\n.soul/.py files:")
    print_files("soul", {'.py'})
else:
    print("No 'soul' folder found.")

# Check voice
if os.path.exists("voice"):
    print("\n.voice/.py .ts .tsx files:")
    print_files("voice", {'.py', '.ts', '.tsx'})
else:
    print("No 'voice' folder found.")


### FILE: vite.config.d.ts

declare const _default: import("vite").UserConfig;
export default _default;


### FILE: vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  base: '/soul/', // ðŸ‘ˆ This makes routing work at ecodia.au/soul/
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: Number(process.env.PORT) || 4173
  },
  preview: {
    port: Number(process.env.PORT) || 4173,
    host: '0.0.0.0',
    allowedHosts: ['voice-3crd.onrender.com']
  }
})


### FILE: src\App.d.ts

declare function App(): import("react/jsx-runtime").JSX.Element;
export default App;


### FILE: src\App.tsx

import { BrowserRouter, Routes, Route } from "react-router-dom";
import Timeline from "./pages/Timeline";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/soul/" element={<Timeline />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;


### FILE: src\main.d.ts

import './index.css';


### FILE: src\main.tsx

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


### FILE: src\vite-env.d.ts

/// <reference types="vite/client" />


### FILE: src\components\ChatModal.tsx

import { useState } from "react";
import { postEvent } from "../services/api";

export default function ChatModal() {
  const [input, setInput] = useState("");

  const handleSubmit = () => {
    if (!input.trim()) return;
    postEvent(input).then(() => {
      setInput("");
      location.reload(); // basic refresh
    });
  };

  return (
    <div className="p-4">
      <input
        className="border border-gray-300 rounded px-3 py-2 w-full mb-2"
        placeholder="Talk to Ecodia..."
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <button
        className="bg-green-600 text-white px-4 py-2 rounded"
        onClick={handleSubmit}
      >
        Submit
      </button>
    </div>
  );
}


### FILE: src\components\timeline.ts

// src/types/timeline.ts

export interface TimelineEntry {
  id: string;
  summary: string;
  timestamp: string;
  emotion?: string;
  // add any additional fields (refs, vector, etc.) as your backend sends them
}


### FILE: src\components\TimelineNode.tsx

// src/components/TimelineNode.tsx

import type { FC } from "react";
import type { TimelineEntry } from "../types/timeline";

interface TimelineNodeProps {
  entry: TimelineEntry;
}

const TimelineNode: FC<TimelineNodeProps> = ({ entry }) => (
  <div className="mb-4 p-4 rounded-2xl shadow bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800">
    <div className="flex items-center justify-between">
      <span className="font-bold">{entry.summary}</span>
      <span className="text-xs text-zinc-500">{new Date(entry.timestamp).toLocaleString()}</span>
    </div>
    {entry.emotion && (
      <div className="mt-1 text-xs italic">{entry.emotion}</div>
    )}
  </div>
);

export default TimelineNode;


### FILE: src\pages\Timeline.d.ts

import React from "react";
declare const Timeline: React.FC;
export default Timeline;


### FILE: src\pages\Timeline.tsx

import { useEffect, useState } from "react";
import { getTimeline } from "../services/api";  // fix: use correct export
import { connectSocket, on } from "../services/socket"; // fix: make sure socket.ts exists/exports these
import TimelineNode from "../components/TimelineNode";
import type { TimelineEntry } from "../types/timeline";

const TimelinePage = () => {
  const [entries, setEntries] = useState<TimelineEntry[]>([]);

  useEffect(() => {
    getTimeline().then(setEntries); // fix: use correct api call

    connectSocket();
    const handleUpdate = (newEntry: TimelineEntry) =>
      setEntries((e) => [newEntry, ...e]);

    on("timeline_update", handleUpdate);

    return () => {
      // off("timeline_update", handleUpdate);
    };
  }, []);

  return (
    <div className="p-4 max-w-3xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">Soul Timeline</h1>
      {entries.map((entry) => (
        <TimelineNode key={entry.id} entry={entry} />
      ))}
    </div>
  );
};

export default TimelinePage;


### FILE: src\services\api.ts

// src/services/api.ts

import type { TimelineEntry } from "../types/timeline";

export async function postEvent(text: string): Promise<any> {
  return await fetch("/api/event", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  }).then(res => res.json());
}

export async function getTimeline(): Promise<TimelineEntry[]> {
  return await fetch("/api/timeline").then(res => res.json());
}


### FILE: src\services\socket.ts

// src/services/socket.ts

import { io, Socket } from "socket.io-client";

let socket: Socket | null = null;

export const connectSocket = () => {
  if (!socket) {
    socket = io(import.meta.env.VITE_SOCKET_URL || "http://localhost:5000");
  }
};

export const on = (event: string, callback: (...args: any[]) => void) => {
  if (!socket) connectSocket();
  socket?.on(event, callback);
};

export const off = (event: string, callback: (...args: any[]) => void) => {
  socket?.off(event, callback);
};


### FILE: src\types\timeline.ts

// src/types/timeline.ts

export interface TimelineEntry {
  id: string;
  summary: string;
  timestamp: string;
  emotion?: string;
  // add any additional fields (refs, vector, etc.) as your backend sends them
}
